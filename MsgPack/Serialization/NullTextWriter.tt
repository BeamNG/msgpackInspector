<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.CodeDom" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="Microsoft.CSharp" #>
<#@ output extension=".cs" #>
#region -- License Terms --
//
// MessagePack for CLI
//
// Copyright (C) 2016 FUJIWARA, Yusuke and contributors
//
//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//
// Contributors:
//    Samuel Cragg
//
#endregion -- License Terms --

// <auto-generated>
//     This code was generated by a NullTextWriter.tt.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>

using System.IO;
using System.Text;

namespace MsgPack.Serialization
{
	internal sealed class NullTextWriter : TextWriter
	{
		internal static NullTextWriter Instance = new NullTextWriter();

		public override Encoding Encoding
		{
			get { return Encoding.UTF8; }
		}

<#
	var notInSLs = 
		new List<Tuple<string, Type[]>>
		{
			Tuple.Create( "Write", new Type[] { typeof( string ), typeof( object ), typeof( object ), typeof( object ) }),
			Tuple.Create( "WriteLine", new Type[] { typeof( string ), typeof( object ), typeof( object ), typeof( object ) })
		}; 
	var notInNetFxCores = 
		new List<Tuple<string, Type[]>>
		{
			Tuple.Create("Close", new Type[ 0 ])
		}; 
	var notInNetStd1_1s = 
		new List<Tuple<string, Type[]>>
		{
			Tuple.Create("Write", new Type[] { typeof( string ), typeof( object ) }),
			Tuple.Create("Write", new Type[] { typeof( string ), typeof( object ), typeof( object ) }),
			Tuple.Create("Write", new Type[] { typeof( string ), typeof( object ), typeof( object ), typeof( object ) }),
			Tuple.Create("WriteLine", new Type[] { typeof( string ), typeof( object ) }),
			Tuple.Create("WriteLine", new Type[] { typeof( string ), typeof( object ), typeof( object ) }),
			Tuple.Create("WriteLine", new Type[] { typeof( string ), typeof( object ), typeof( object ), typeof( object ) }),
			Tuple.Create("Close", new Type[ 0 ])
		}; 
	var notInNetStd1_3s = 
		new List<Tuple<string, Type[]>>
		{
			Tuple.Create("Close", new Type[ 0 ])
		}; 

	using (var provider = new CSharpCodeProvider())
	{
		IEnumerable<MethodInfo> methods =
			typeof(System.IO.TextWriter).GetMethods()
				.Where(m => !m.IsFinal && m.IsVirtual) // A method we can override
				.Where(m => m.ReturnType == typeof(void)) // We're generating empty methods only
				.Where(m => !m.IsSpecialName); // Exclude properties

		foreach (MethodInfo method in methods)
		{
			var unsupportedPlatforms = new List<string>();
			if (IsNotIn(method, notInSLs))
			{
				unsupportedPlatforms.Add("SILVERLIGHT");
			}
			if (IsNotIn(method, notInNetFxCores))
			{
				unsupportedPlatforms.Add("NETFX_CORE");
			}
			if (IsNotIn(method, notInNetStd1_1s))
			{
				unsupportedPlatforms.Add("NETSTANDARD1_1");
			}
			if (IsNotIn(method, notInNetStd1_3s))
			{
				unsupportedPlatforms.Add("NETSTANDARD1_3");
			}

			if (unsupportedPlatforms.Count > 0 )
			{
#>
#if <#= String.Join( " && ", unsupportedPlatforms.Select(s => "!" + s )) #>
<#
			}

			var parameters =
				method.GetParameters().Length == 0
					? "()"
					: "( " + String.Join(", ", method.GetParameters().Select(p => provider.GetTypeOutput(new CodeTypeReference(p.ParameterType)) + " " + p.Name) ) + " )";
#>
		public override void <#= method.Name #><#= parameters #> { }
<#
			if (unsupportedPlatforms.Count > 0 )
			{
#>
#endif // <#= String.Join( " && ", unsupportedPlatforms.Select(s => "!" + s )) #>
<#
			}
		}
	}
#>
	}
}
<#+
private static bool IsNotIn(MethodInfo method, IList<Tuple<string, Type[]>> unavailableMethodSignatures)
{
	return unavailableMethodSignatures.Any(sig => sig.Item1 == method.Name && sig.Item2.SequenceEqual(method.GetParameters().Select(p => p.ParameterType)));
}
#>
